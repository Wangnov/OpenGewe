# 开发守则

## 项目概述

OpenGewe是一个基于GeWeAPI的异步Python微信机器人框架，专注于提供个人微信二次开发能力。项目采用异步架构，支持插件系统，并提供Web管理面板。

- **核心功能**：微信机器人API、消息处理、群管理、插件系统、Web管理面板
- **技术栈**：Python 3.9+、asyncio、aiohttp、Celery(可选)、Redis/RabbitMQ(可选)
- **配置方式**：TOML格式配置文件

## 项目架构

### 核心模块 (src/opengewe/)

- **client.py**: 核心客户端类，所有API操作的入口点
- **callback/**: 处理各类回调消息
  - **handlers/**: 消息处理器
  - **models/**: 回调消息模型
- **logger/**: 日志系统
- **mixin/**: 客户端功能混入类
- **modules/**: API模块（登录、消息、群聊等）
- **queue/**: 消息队列实现
- **utils/**: 工具函数和类

### 插件系统 (plugins/)

- **utils/**: 插件工具类和装饰器
- **ExamplePlugin/**: 示例插件
- **其他自定义插件目录**

### Web管理面板

- **webpanel/**: 后端API (FastAPI)
  - **app/**: 应用代码
    - **api/**: API路由
    - **core/**: 核心功能
    - **models/**: 数据模型
    - **schemas/**: 请求/响应模式
    - **services/**: 业务逻辑
    - **utils/**: 工具函数
- **webpanel-frontend/**: 前端界面
  - **src/**: 源代码
    - **components/**: UI组件
    - **pages/**: 页面
    - **services/**: API服务
    - **utils/**: 工具函数

## 代码规范

### 命名规范

- **文件名**：使用小写蛇形命名法 (snake_case)
- **类名**：使用大驼峰命名法 (PascalCase)
- **函数和变量**：使用小写蛇形命名法 (snake_case)
- **常量**：使用大写蛇形命名法 (UPPER_SNAKE_CASE)
- **私有方法/属性**：使用单下划线前缀 (_method_name)

### 异步编程规范

- **强制使用异步**：所有I/O操作必须使用异步方式
- **禁止混用**：不得在异步函数中使用阻塞式I/O
- **异步函数命名**：异步函数应使用`async_`前缀或表明异步性质的名称

### 错误处理规范

- **异常捕获**：必须捕获并处理所有可预见的异常
- **日志记录**：异常必须记录到日志，包含足够的上下文信息
- **优雅降级**：核心功能应有降级策略，如高级队列不可用时降级到简单队列

## 性能优化规范

### 异步性能优化

- **并发控制**：
  - 使用`asyncio.Semaphore`限制并发请求数
  - 避免无限制的并发任务创建
  - 对于大量并发任务，使用任务池管理

- **I/O效率**：
  - 使用`aiohttp.ClientSession`复用连接
  - 设置合理的超时时间
  - 使用连接池管理HTTP连接

- **任务调度**：
  - 使用`asyncio.gather`并行执行无依赖的任务
  - 对于有依赖的任务，使用`asyncio.create_task`和`await`管理执行顺序
  - 避免使用`asyncio.sleep(0)`进行任务切换，使用更高效的方法

### 内存优化

- **数据结构选择**：
  - 大量小对象使用`__slots__`减少内存占用
  - 处理大量数据时使用生成器而非列表
  - 使用`collections`模块的专用数据结构（如`defaultdict`、`Counter`）

- **缓存策略**：
  - 使用`functools.lru_cache`缓存函数结果
  - 实现自定义TTL缓存机制避免内存泄漏
  - 定期清理不再使用的缓存数据

- **资源管理**：
  - 使用上下文管理器（`with`语句）确保资源及时释放
  - 大文件处理使用流式处理而非一次性加载
  - 图片处理使用惰性加载和处理

### 消息队列优化

- **简单队列优化**：
  - 调整消息发送间隔（`delay`参数）平衡吞吐量和API限制
  - 实现优先级队列处理紧急消息
  - 添加队列状态监控

- **高级队列优化**：
  - 配置合适的worker数量
  - 使用`lz4`压缩序列化数据
  - 设置合理的任务超时和重试策略
  - 实现任务结果缓存

### 数据库优化

- **ORM使用**：
  - 避免N+1查询问题
  - 使用批量操作代替循环单条操作
  - 只查询需要的字段（避免`SELECT *`）

- **连接管理**：
  - 使用连接池管理数据库连接
  - 设置合理的连接池大小
  - 定期检查连接健康状态

- **查询优化**：
  - 为常用查询添加索引
  - 复杂查询使用原生SQL而非ORM
  - 大量数据分页查询

### 前端性能优化

- **资源加载**：
  - 使用代码分割减小初始加载体积
  - 实现组件懒加载
  - 使用适当的缓存策略

- **渲染优化**：
  - 使用`React.memo`避免不必要的重渲染
  - 使用虚拟列表渲染大量数据
  - 优化组件更新逻辑

- **API调用**：
  - 实现请求合并（Request batching）
  - 使用SWR或React Query进行数据缓存
  - 实现请求去抖动和节流

### 性能监控

- **服务器监控**：
  - 记录API响应时间
  - 监控内存使用情况
  - 跟踪并发连接数

- **客户端监控**：
  - 记录消息处理延迟
  - 监控队列长度
  - 跟踪API调用成功率

- **性能基准**：
  - 建立关键操作的性能基准
  - 定期运行性能测试
  - 比较不同版本间的性能变化

## 功能实现规范

### 核心客户端扩展

- **添加新API方法**：
  1. 在适当的mixin类中添加方法
  2. 确保方法为异步(async)
  3. 添加类型提示和文档字符串
  4. 在client.py中确保mixin类被正确继承

- **修改现有API**：
  1. 保持向后兼容性
  2. 在CHANGELOG.md中记录变更
  3. 更新相关文档字符串

### 消息处理系统扩展

- **添加新消息类型**：
  1. 在`callback/models/`中创建消息模型类
  2. 在`callback/handlers/`中创建对应处理器
  3. 在回调处理主流程中注册新消息类型

### 配置系统修改

- **修改配置项**：
  1. 同时更新`main_config.toml`和`main_config_example.toml`
  2. 确保提供向后兼容的默认值
  3. 在代码中添加配置验证逻辑

## 测试规范

### 测试结构

- **测试目录**：所有测试文件放在`test/`目录下
- **测试文件命名**：使用`test_`前缀，如`test_client.py`
- **测试类命名**：使用`Test`前缀，如`TestClient`
- **测试函数命名**：使用`test_`前缀，如`test_send_message`

### 单元测试

- **必须测试的内容**：
  1. 所有公共API方法
  2. 关键的内部函数
  3. 错误处理逻辑
  4. 边界条件

- **测试框架**：使用pytest
- **异步测试**：使用pytest-asyncio处理异步测试
- **Mock对象**：使用unittest.mock或pytest-mock模拟外部依赖

### 集成测试

- **测试范围**：
  1. 客户端与API服务器的交互
  2. 插件系统的加载和卸载
  3. 消息队列的处理流程
  4. Web面板与后端API的交互

- **环境配置**：使用专门的测试配置文件
- **数据隔离**：测试数据库与生产数据库分离

### 插件测试

- **插件测试文件**：放在插件目录下的`tests/`子目录中
- **测试内容**：
  1. 插件初始化
  2. 事件处理器
  3. 定时任务
  4. 配置读取

- **测试工具**：使用`test_plugin_functionality.py`中的测试工具

### 性能测试

- **基准测试**：
  - 使用`pytest-benchmark`进行基准测试
  - 测量关键操作的执行时间
  - 比较优化前后的性能差异

- **负载测试**：
  - 模拟高并发场景
  - 测试系统在不同负载下的响应时间
  - 确定系统的性能瓶颈

- **内存分析**：
  - 使用`memory_profiler`分析内存使用
  - 检测内存泄漏
  - 优化大内存消耗的操作

## 文档规范

### 代码文档

- **模块文档**：每个Python模块(.py文件)必须有文档字符串，说明模块用途
- **类文档**：每个类必须有文档字符串，说明类的功能和用法
- **方法文档**：公共方法必须有文档字符串，包括：
  1. 功能描述
  2. 参数说明
  3. 返回值说明
  4. 异常说明
  5. 示例代码（可选）

- **文档格式**：使用Google风格的文档字符串

```python
def send_message(self, to_user: str, content: str) -> dict:
    """发送文本消息到指定用户
    
    Args:
        to_user: 接收消息用户的wxid
        content: 消息内容
        
    Returns:
        dict: 包含消息发送结果的字典
        
    Raises:
        NetworkError: 网络连接失败时
        AuthError: 认证失败时
    
    Example:
        >>> await client.send_message("wxid_123", "你好")
        {'status': 'success', 'message_id': '123456'}
    """
```

### 项目文档

- **README.md**：项目主文档，包含：
  1. 项目简介
  2. 安装指南
  3. 快速开始
  4. 主要功能
  5. 示例代码

- **API文档**：使用自动生成工具（如Sphinx）生成API文档
- **开发指南**：提供详细的开发指南，包括：
  1. 环境设置
  2. 代码风格
  3. 提交规范
  4. 测试指南

### 更新文档

- **修改功能时**：同步更新对应的文档
- **CHANGELOG.md**：记录所有版本变更，格式遵循[Keep a Changelog](https://keepachangelog.com/)
- **版本号**：遵循语义化版本规范

## 版本控制规范

### 分支管理

- **主分支**：
  - `main`：稳定版本分支，只接受经过测试的合并请求
  - `dev`：开发分支，用于集成功能分支

- **功能分支**：从`dev`分支创建，命名格式为`feature/功能名称`
- **修复分支**：从`main`分支创建，命名格式为`hotfix/问题描述`
- **发布分支**：从`dev`分支创建，命名格式为`release/版本号`

### 提交规范

- **提交消息格式**：
  ```
  <类型>(<范围>): <描述>
  
  [可选的详细描述]
  
  [可选的脚注]
  ```

- **类型**：
  - `feat`：新功能
  - `fix`：修复Bug
  - `docs`：文档更新
  - `style`：代码风格变更（不影响代码运行）
  - `refactor`：重构（既不是新功能也不是修复Bug）
  - `perf`：性能优化
  - `test`：添加测试
  - `chore`：构建过程或辅助工具变更

- **范围**：指定提交影响的部分，如`client`、`plugin`、`webpanel`等

### 版本号管理

- **版本号格式**：遵循[语义化版本2.0.0](https://semver.org/)，格式为`X.Y.Z`
  - `X`：主版本号，不兼容的API变更
  - `Y`：次版本号，向后兼容的功能新增
  - `Z`：修订号，向后兼容的问题修复

- **版本更新流程**：
  1. 在`pyproject.toml`中更新版本号
  2. 更新`CHANGELOG.md`
  3. 创建版本标签
  4. 发布到PyPI

### 发布流程

- **预发布**：
  1. 从`dev`分支创建`release/X.Y.Z`分支
  2. 在发布分支上进行最终测试和修复
  3. 更新版本号和CHANGELOG.md

- **正式发布**：
  1. 将发布分支合并到`main`分支
  2. 在`main`分支上创建版本标签
  3. 将`main`分支合并回`dev`分支
  4. 发布到PyPI

## 插件开发规范

### 插件结构

- **必要文件**：
  - `main.py`: 插件主类
  - `config.toml`: 插件配置
  - `README.md`: 插件文档

- **插件主类**：
  - 必须继承`PluginBase`类
  - 必须实现`__init__`方法
  - 可选实现`async_init`方法进行异步初始化

### 事件处理

- **注册事件处理器**：使用装饰器（如`@on_text_message`）
- **处理器签名**：`async def handler(self, client, message)`
- **优先级控制**：使用装饰器的`priority`参数

### 定时任务

- **注册定时任务**：使用`@schedule`装饰器
- **支持的触发器**：`interval`、`cron`、`date`
- **任务签名**：`async def task(self, client)`

### 插件配置

- **配置文件格式**：TOML
- **配置读取**：在`__init__`中读取配置
- **错误处理**：配置读取失败时应提供合理默认值

### 插件性能优化

- **资源管理**：
  - 在`on_disable`方法中释放所有资源
  - 使用弱引用避免循环引用
  - 避免在插件中保存大量状态数据

- **事件处理优化**：
  - 使用优先级控制处理顺序
  - 耗时操作放在单独的任务中执行
  - 实现消息过滤避免不必要的处理

- **定时任务优化**：
  - 避免过于频繁的定时任务
  - 合并相似的定时任务
  - 使用批处理代替单条处理

## Web面板开发规范

### 后端开发 (FastAPI)

- **API路由**：在`app/api/`目录下按功能模块组织
- **数据模型**：使用SQLAlchemy ORM，在`app/models/`定义
- **请求验证**：使用Pydantic模型，在`app/schemas/`定义
- **业务逻辑**：放在`app/services/`目录下
- **依赖注入**：使用FastAPI的依赖注入系统

### 前端开发

- **技术栈**：React + Vite
- **组件开发**：组件放在`src/components/`目录下
- **API调用**：使用`src/services/`中的服务函数
- **状态管理**：使用React Context API
- **路由管理**：使用React Router

## 关键文件交互规范

### 核心模块交互

- **修改client.py时**：
  - 检查是否影响mixin类的继承
  - 确保不破坏现有API方法签名

- **修改消息模型时**：
  - 同步更新对应的消息处理器
  - 确保插件系统兼容性

- **修改队列实现时**：
  - 保持简单队列和高级队列的接口一致性
  - 更新相关文档和示例

### 插件系统交互

- **修改plugin_base.py时**：
  - 确保向后兼容性
  - 更新示例插件
  - 更新插件开发文档

- **添加新装饰器时**：
  - 在utils/decorators.py中实现
  - 在示例插件中展示用法
  - 更新插件开发文档

### Web面板交互

- **修改API端点时**：
  - 同步更新前端API服务
  - 更新API文档

- **修改数据模型时**：
  - 同步更新相关的Pydantic模型
  - 确保数据库迁移脚本正确

## AI决策规范

### 功能修改优先级

1. **安全性修复** - 最高优先级
2. **兼容性维护** - 确保与GeWeAPI的兼容
3. **核心功能增强** - 改进现有功能
4. **新功能添加** - 在不破坏现有功能的前提下
5. **性能优化** - 在功能稳定后进行

### 技术选择决策树

- **是否添加新依赖？**
  - 如果是核心功能：尽量使用现有依赖
  - 如果是可选功能：可以添加到optional_dependencies

- **同步vs异步实现？**
  - 默认选择异步实现
  - 只有CPU密集型操作可以考虑同步实现

- **简单队列vs高级队列？**
  - 单机部署：使用简单队列
  - 分布式部署：使用高级队列

- **性能优化vs可读性？**
  - 核心路径：优先考虑性能
  - 非核心路径：优先考虑可读性
  - 总是添加注释解释复杂的优化

### 代码修改指南

- **小改动**：直接修改相关文件
- **中等改动**：先创建测试，再实现功能
- **大改动**：先设计接口，再分阶段实现
- **性能优化**：先建立基准，再进行优化，最后验证效果

## 禁止事项

- **禁止破坏异步架构**：不得在异步函数中使用阻塞式I/O
- **禁止硬编码配置**：所有配置应通过配置文件或环境变量提供
- **禁止直接修改数据库**：必须通过ORM模型操作数据
- **禁止循环导入**：谨慎设计模块依赖关系
- **禁止忽略类型提示**：所有新代码必须有完整的类型提示
- **禁止不处理异常**：所有可预见的异常必须被捕获并处理
- **禁止破坏插件兼容性**：插件API变更必须保持向后兼容
- **禁止在核心模块中添加非必要依赖**：保持核心模块轻量
- **禁止混用同步和异步代码**：统一使用异步编程模型
- **禁止在前端直接操作DOM**：使用React的声明式编程模型
- **禁止提交未测试的代码**：新功能必须有对应的测试
- **禁止忽略文档更新**：代码变更必须同步更新文档
- **禁止不遵循版本控制规范**：所有提交必须遵循提交规范
- **禁止过早优化**：先确保功能正确，再考虑优化
- **禁止优化无关紧要的代码路径**：集中精力优化热点代码
- **禁止为了性能牺牲代码可维护性**：除非有明确的性能要求和测量数据 